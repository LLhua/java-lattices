<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConceptLattice.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">org.thegalactic.lattice</a> &gt; <span class="el_source">ConceptLattice.java</span></div><h1>ConceptLattice.java</h1><pre class="source lang-java linenums">package org.thegalactic.lattice;

/*
 * ConceptLattice.java
 *
 * Copyright: 2010-2015 Karell Bertet, France
 * Copyright: 2015-2016 The Galactic Organization, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices.
 * You can redistribute it and/or modify it under the terms of the CeCILL-B license.
 */
import org.thegalactic.context.Context;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.io.IOException;
import java.util.List;

import org.thegalactic.util.ComparableSet;
import org.thegalactic.dgraph.DAGraph;
import org.thegalactic.dgraph.ConcreteDGraph;
import org.thegalactic.dgraph.Edge;
import org.thegalactic.dgraph.Node;
import org.thegalactic.io.Filer;
import org.thegalactic.lattice.io.ConceptLatticeIOFactory;

/**
 * This class extends class {@link Lattice} to provide specific methods to
 * manipulate both a concept lattice or a closed set lattice.
 *
 * This class provides methods implementing classical operation on a concept
 * lattice: join and meet reduction, concepts sets reduction, ...
 *
 * This class also provides two static method generating a concept lattice:
 * methods {@link #diagramLattice} and {@link #completeLattice} both computes
 * the closed set lattice of a given closure system. The firt one computes the
 * hasse diagram of the closed set lattice by invoking method
 * {@link #immediateSuccessors}. This method implements an adaptation of the
 * well-known Bordat algorithm that also computes the dependance graph of the
 * lattice where at once the minimal generators and the canonical direct basis
 * of the lattice are encoded. The second static method computes the
 * transitively closure of the lattice as the inclusion relation defined on all
 * the closures generated by method {@link ClosureSystem#allClosures} that
 * implements the well-known Wille algorithm.
 *
 * ![ConceptLattice](ConceptLattice.png)
 *
 * @uml ConceptLattice.png
 * !include resources/org/thegalactic/dgraph/DAGraph.iuml
 * !include resources/org/thegalactic/dgraph/DGraph.iuml
 * !include resources/org/thegalactic/dgraph/Edge.iuml
 * !include resources/org/thegalactic/dgraph/Node.iuml
 * !include resources/org/thegalactic/lattice/Lattice.iuml
 * !include resources/org/thegalactic/lattice/ConceptLattice.iuml
 * !include resources/org/thegalactic/lattice/Concept.iuml
 *
 * hide members
 * show ConceptLattice members
 * class ConceptLattice #LightCyan
 * title ConceptLattice UML graph
 */
public class ConceptLattice extends Lattice {

    /**
     * Generate the lattice composed of all the antichains of this component
     * ordered with the inclusion relation.
     *
     * This treatment is performed in O(??) by implementation of Nourine
     * algorithm that consists in a sequence of doubling intervals of nodes.
     *
     * @param dag a directed acyclic graph
     *
     * @return the concept lattice
     */
    public static ConceptLattice idealLattice(DAGraph dag) {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (!dag.isAcyclic()) {</span>
<span class="nc" id="L80">            return null;</span>
        }
        // initialise the poset of ideals with the emptyset
<span class="fc" id="L83">        ConceptLattice conceptLattice = new ConceptLattice();</span>
<span class="fc" id="L84">        conceptLattice.addNode(new Concept(true, false));</span>
        // travel on graph according to a topological sort
<span class="fc" id="L86">        DAGraph graph = new DAGraph(dag);</span>
<span class="fc" id="L87">        graph.transitiveClosure();</span>
        // treatment of nodes according to a topological sort
<span class="fc" id="L89">        List&lt;Node&gt; sort = graph.topologicalSort();</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for (Node x : sort) {</span>
            // computation of Jx
<span class="fc" id="L92">            TreeSet&lt;Node&gt; jxmoins = new TreeSet&lt;Node&gt;(graph.getPredecessorNodes(x));</span>
            // storage of new ideals in a set
<span class="fc" id="L94">            TreeSet&lt;Concept&gt; toAdd = new TreeSet&lt;Concept&gt;();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            for (Object j1 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                if (((Concept) j1).containsAllInA(jxmoins)) {</span>
<span class="fc" id="L97">                    Concept newJ = new Concept(true, false);</span>
<span class="fc" id="L98">                    newJ.addAllToA(((TreeSet) ((Concept) j1).getSetA()));</span>
<span class="fc" id="L99">                    newJ.addToA(x);</span>
<span class="fc" id="L100">                    toAdd.add(newJ);</span>
                }
<span class="fc" id="L102">            }</span>
            // addition of the new ideals in conceptLattice
<span class="fc bfc" id="L104" title="All 2 branches covered.">            for (Concept newJ : toAdd) {</span>
<span class="fc" id="L105">                conceptLattice.addNode(newJ);</span>
<span class="fc" id="L106">            }</span>
<span class="fc" id="L107">        }</span>
        // computation of the inclusion relaton
<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (Object node1 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            for (Object node2 : conceptLattice.getNodes()) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">                if (((Concept) node1).containsAllInA(((Concept) node2).getSetA())) {</span>
<span class="fc" id="L112">                    conceptLattice.addEdge((Node) node2, (Node) node1);</span>
                }
<span class="fc" id="L114">            }</span>
<span class="fc" id="L115">        }</span>
<span class="fc" id="L116">        conceptLattice.transitiveReduction();</span>
<span class="fc" id="L117">        return conceptLattice;</span>
    }

    /*
     * -------- STATIC CLOSEDSET LATTICE GENERATION FROM AN ImplicationalSystem OR A CONTEXT ------------------
     */
    /**
     * Generates and returns the complete (i.e. transitively closed) closed set
     * lattice of the specified closure system, that can be an implicational
     * system (ImplicationalSystem) or a context.
     *
     * The lattice is generated using the well-known Next Closure algorithm. All
     * closures are first generated using the method:
     * {@link ClosureSystem#allClosures} that implements the well-known Next
     * Closure algorithm. Then, all concepts are ordered by inclusion.
     *
     * @param init a closure system (an ImplicationalSystem or a Context)
     *
     * @return a concept lattice
     */
    public static ConceptLattice completeLattice(ClosureSystem init) {
<span class="fc" id="L138">        ConceptLattice lattice = new ConceptLattice();</span>
        // compute all the closed set with allClosures
<span class="fc" id="L140">        Vector&lt;Concept&gt; allclosure = init.allClosures();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (Concept cl : allclosure) {</span>
<span class="fc" id="L142">            lattice.addNode(cl);</span>
<span class="fc" id="L143">        }</span>

        // an edge corresponds to an inclusion between two closed sets
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (Object source : lattice.getNodes()) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (Object target : lattice.getNodes()) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                if (((Concept) target).containsAllInA(((Concept) source).getSetA())) {</span>
<span class="fc" id="L149">                    lattice.addEdge((Node) source, (Node) target);</span>
                }
<span class="fc" id="L151">            }</span>
<span class="fc" id="L152">        }</span>
        // Hasse diagram is computed
<span class="fc" id="L154">        return lattice;</span>
    }

    /**
     * Generates and returns the Hasse diagram of the closed set lattice of the
     * specified closure system, that can be an implicational system
     * (ImplicationalSystem) or a context.
     *
     * The Hasse diagramm of the closed set lattice is obtained by a recursively
     * generation of immediate successors of a given closed set, starting from
     * the botom closed set. Implemented algorithm is an adaptation of Bordat's
     * algorithm where the dependance graph is computed while the lattice is
     * generated. This treatment is performed in O(cCl|S|^3log g) where S is the
     * initial set of elements, c is the number of closed sets that could be
     * exponential in the worst case, Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * The dependance graph of the lattice is also computed while the lattice
     * generation. The dependance graph of a lattice encodes at once the minimal
     * generators and the canonical direct basis of the lattice .
     *
     * @param init a closure system (an ImplicationalSystem or a Context)
     *
     * @return a concept lattice
     */
    public static ConceptLattice diagramLattice(ClosureSystem init) {
<span class="fc" id="L180">        ConceptLattice lattice = new ConceptLattice();</span>
        //if (Diagram) {
        // computes the dependance graph of the closure system
        // addition of nodes in the precedence graph
<span class="fc" id="L184">        ConcreteDGraph graph = new ConcreteDGraph();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (Comparable c : init.getSet()) {</span>
<span class="fc" id="L186">            graph.addNode(new Node(c));</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">        lattice.setDependencyGraph(graph);</span>
        // intialize the close set lattice with botom element
<span class="fc" id="L190">        Concept bot = new Concept(init.closure(new ComparableSet()), false);</span>
<span class="fc" id="L191">        lattice.addNode(bot);</span>
        // recursive genaration from the botom element with diagramLattice
<span class="fc" id="L193">        lattice.recursiveDiagramLattice(bot, init);</span>
        // minimalisation of edge's content to get only inclusion-minimal valuation for each edge
        /**
         * for (Edge ed : lattice.dependanceGraph.getEdges()) {
         * TreeSet&lt;ComparableSet&gt; valEd = new
         * TreeSet&lt;ComparableSet&gt;(((TreeSet&lt;ComparableSet&gt;)ed.getContent()));
         * for (ComparableSet X1 : valEd) for (ComparableSet X2 : valEd) if
         * (X1.containsAll(X2) &amp;&amp; !X2.containsAll(X1))
         * ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).remove(X1); }*
         */
<span class="fc" id="L203">        return lattice;</span>
    }

    /**
     * Generates and returns the Hasse diagram of the closed set iceberg of the
     * specified context.
     *
     * The Hasse diagram of the closed set iceberg is obtained by a recursively
     * generation of immediate successors of a given closed set, starting from
     * the bottom closed set. Implemented algorithm is an adaptation of Bordat's
     * algorithm where the dependence graph is computed while the lattice is
     * generated. This treatment is performed in O(cCl|S|^3log g) where S is the
     * initial set of elements, c is the number of closed sets that could be
     * exponential in the worst case, Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice. The iceberg
     * stops when the immediate successors support is inferior to the support
     * value.
     *
     * The dependence graph of the lattice is also computed while the lattice
     * generation. The dependence graph of a lattice encodes at once the minimal
     * generators and the canonical direct basis of the lattice .
     *
     * @param init    a closure system (an ImplicationalSystem or a Context)
     * @param support a support value, between 0 and 1.
     *
     * @return a concept iceberg
     */
    public static ConceptLattice diagramIceberg(Context init, double support) {
<span class="nc" id="L231">        ConceptLattice lattice = new ConceptLattice();</span>
        // computes the dependance graph of the closure system
        // addition of nodes in the precedence graph
<span class="nc" id="L234">        ConcreteDGraph graph = new ConcreteDGraph();</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        for (Comparable c : init.getSet()) {</span>
<span class="nc" id="L236">            graph.addNode(new Node(c));</span>
<span class="nc" id="L237">        }</span>
<span class="nc" id="L238">        lattice.setDependencyGraph(graph);</span>
        // intialize the close set lattice with bottom element
<span class="nc" id="L240">        Concept bot = new Concept(init.closure(new ComparableSet()), false);</span>
<span class="nc" id="L241">        lattice.addNode(bot);</span>
<span class="nc" id="L242">        int threshold = (int) (support * init.getExtent(bot.getSetA()).size());</span>
        // recursive genaration from the botom element with diagramLattice
<span class="nc" id="L244">        lattice.recursiveDiagramIceberg(bot, init, threshold);</span>
<span class="nc" id="L245">        return lattice;</span>
    }

    /*
     * ------------- CONSTRUCTORS ------------------
     */
    /**
     * Constructs this component with an empty set of nodes.
     */
    public ConceptLattice() {
<span class="fc" id="L255">        super();</span>
<span class="fc" id="L256">    }</span>

    /**
     * Constructs this component with the specified set of concepts, and empty
     * treemap of successors and predecessors.
     *
     * @param set the set of nodes
     */
    public ConceptLattice(TreeSet&lt;Concept&gt; set) {
<span class="fc" id="L265">        super((TreeSet) set);</span>
<span class="fc" id="L266">    }</span>

    /**
     * Constructs this component as a shallow copy of the specified lattice.
     *
     * Concept lattice property is checked for the specified lattice. When not
     * verified, this component is constructed with an empty set of nodes.
     *
     * @param lattice the lattice to be copied
     */
    public ConceptLattice(Lattice lattice) {
<span class="fc" id="L277">        super(lattice);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (!this.isConceptLattice()) {</span>
<span class="fc" id="L279">            this.setNodes(new TreeSet&lt;Node&gt;());</span>
<span class="fc" id="L280">            this.setSuccessors(new TreeMap&lt;Node, SortedSet&lt;Edge&gt;&gt;());</span>
<span class="fc" id="L281">            this.setPredecessors(new TreeMap&lt;Node, SortedSet&lt;Edge&gt;&gt;());</span>
        }
<span class="fc" id="L283">    }</span>

    /*
     * ------------- CONCEPT LATTICE CHEKING METHOD ------------------
     */
    /**
     * Check if nodes of this component are concepts.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean containsConcepts() {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for (Object node : this.getNodes()) {</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (!(node instanceof Concept)) {</span>
<span class="fc" id="L298">                return false;</span>
            }
<span class="fc" id="L300">        }</span>
<span class="fc" id="L301">        return true;</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean isConceptLattice() {
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">        return this.isLattice() &amp;&amp; this.containsConcepts();</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts with non
     * null set A.
     *
     * @return a boolean
     *
     * @todo Comment the return: conception
     */
    public boolean containsAllSetA() {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L325">            return false;</span>
        }
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (Object node : this.getNodes()) {</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">            if (!((Concept) node).hasSetA()) {</span>
<span class="nc" id="L329">                return false;</span>
            }
<span class="fc" id="L331">        }</span>
<span class="fc" id="L332">        return true;</span>
    }

    /**
     * Check if this component is a lattice whose nodes are concepts with non
     * null set A.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean containsAllSetB() {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L345">            return false;</span>
        }
<span class="fc bfc" id="L347" title="All 2 branches covered.">        for (Object node : this.getNodes()) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (!((Concept) node).hasSetB()) {</span>
<span class="fc" id="L349">                return false;</span>
            }
<span class="fc" id="L351">        }</span>
<span class="fc" id="L352">        return true;</span>
    }

    /**
     * Returns a clone of this component composed of a clone of each concept and
     * each edge.
     *
     * @return a concept lattice
     */
    @Override
    public ConceptLattice clone() {
<span class="fc" id="L363">        ConceptLattice conceptLattice = new ConceptLattice();</span>
<span class="fc" id="L364">        TreeMap&lt;Concept, Concept&gt; copy = new TreeMap&lt;Concept, Concept&gt;();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (Object node : this.getNodes()) {</span>
<span class="fc" id="L366">            Concept c = (Concept) node;</span>
<span class="fc" id="L367">            Concept c2 = c.clone();</span>
<span class="fc" id="L368">            copy.put(c, c2);</span>
<span class="fc" id="L369">            conceptLattice.addNode(c2);</span>
<span class="fc" id="L370">        }</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (Object ed : this.getEdges()) {</span>
<span class="fc" id="L372">            conceptLattice.addEdge(new Edge(</span>
<span class="fc" id="L373">                    copy.get(((Edge) ed).getSource()),</span>
<span class="fc" id="L374">                    copy.get(((Edge) ed).getTarget()),</span>
<span class="fc" id="L375">                    ((Edge) ed).getContent()</span>
            ));
<span class="fc" id="L377">        }</span>
<span class="fc" id="L378">        return conceptLattice;</span>
    }

    /*
     * ------------- SET A AND SET B HANDLING METHOD ------------------
     */
    /**
     * Returns concept defined by setA and setB; null if not found.
     *
     * @param setA intent of the concept to find
     * @param setB extent of the concept to find
     *
     * @return concept defined by setA and setB; null if not found.
     */
    public Concept getConcept(ComparableSet setA, ComparableSet setB) {
<span class="fc" id="L393">        SortedSet&lt;Node&gt; setNodes = this.getNodes();</span>
<span class="fc" id="L394">        Concept cpt = null;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (Node node : setNodes) {</span>
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">            if ((setA.equals(((Concept) node).getSetA())) &amp;&amp; (setB.equals(((Concept) node).getSetB()))) {</span>
<span class="fc" id="L397">                cpt = (Concept) node;</span>
            }
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">        return cpt;</span>
    }

    /**
     * Replace set A in each concept of the lattice with the null value.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean removeAllSetA() {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L412">            return false;</span>
        }
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        for (Object node : this.getNodes()) {</span>
<span class="nc" id="L415">            Concept c = (Concept) node;</span>
<span class="nc" id="L416">            c.putSetA(null);</span>
<span class="nc" id="L417">        }</span>
<span class="fc" id="L418">        return true;</span>
    }

    /**
     * Replace set B in each concept of the lattice with the null value.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean removeAllSetB() {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L430">            return false;</span>
        }
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        for (Object node : this.getNodes()) {</span>
<span class="nc" id="L433">            Concept c = (Concept) node;</span>
<span class="nc" id="L434">            c.putSetB(null);</span>
<span class="nc" id="L435">        }</span>
<span class="fc" id="L436">        return true;</span>
    }

    /**
     * Replace null set A in each join irreducible concept with a set containing
     * node ident.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean initialiseSetAForJoin() {
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L449">            return false;</span>
        }
<span class="fc" id="L451">        TreeSet&lt;Node&gt; joinIrr = this.joinIrreducibles();</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        for (Object node : this.getNodes()) {</span>
<span class="nc" id="L453">            Concept c = (Concept) node;</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">            if (!c.hasSetA() &amp;&amp; joinIrr.contains(c)) {</span>
<span class="nc" id="L455">                ComparableSet setX = new ComparableSet();</span>
<span class="nc" id="L456">                setX.add(Integer.valueOf(c.getIdentifier()));</span>
<span class="nc" id="L457">                c.putSetA(setX);</span>
            }
<span class="nc" id="L459">        }</span>
<span class="fc" id="L460">        return true;</span>
    }

    /**
     * Replace null set B in each meet irreducible concept with a set containing
     * node ident.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean initialiseSetBForMeet() {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L473">            return false;</span>
        }
<span class="fc" id="L475">        TreeSet&lt;Node&gt; meetIrr = this.meetIrreducibles();</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        for (Object node : this.getNodes()) {</span>
<span class="nc" id="L477">            Concept c = (Concept) node;</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">            if (!c.hasSetB() &amp;&amp; meetIrr.contains(c)) {</span>
<span class="nc" id="L479">                ComparableSet setX = new ComparableSet();</span>
<span class="nc" id="L480">                setX.add(Integer.valueOf(c.getIdentifier()));</span>
<span class="nc" id="L481">                c.putSetB(setX);</span>
            }
<span class="nc" id="L483">        }</span>
<span class="fc" id="L484">        return true;</span>
    }

    /*
     * --------------- INCLUSION REDUCTION METHODS ------------
     */
    /**
     * Replaces, if not empty, set A of each concept with the difference between
     * itself and set A of its predecessors; Then replaces, if not empty, set B
     * of each concept by the difference between itself and set B of its
     * successors.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean makeInclusionReduction() {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L502">            return false;</span>
        }
<span class="fc" id="L504">        boolean setA = this.containsAllSetA();</span>
<span class="fc" id="L505">        boolean setB = this.containsAllSetB();</span>
<span class="pc bpc" id="L506" title="3 of 4 branches missed.">        if (!setA &amp;&amp; !setB) {</span>
<span class="nc" id="L507">            return false;</span>
        }
        // makes setA inclusion reduction
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (setA) {</span>
            // computation of an inverse topological sort
<span class="fc" id="L512">            this.transpose();</span>
<span class="fc" id="L513">            List&lt;Node&gt; sort = this.topologicalSort();</span>
<span class="fc" id="L514">            this.transpose();</span>
            // reduction of set A
<span class="fc bfc" id="L516" title="All 2 branches covered.">            for (Node to : sort) {</span>
<span class="fc" id="L517">                Concept cto = (Concept) to;</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">                for (Object source : this.getPredecessorNodes(to)) {</span>
<span class="fc" id="L519">                    Concept csource = (Concept) source;</span>
<span class="fc" id="L520">                    cto.getSetA().removeAll(csource.getSetA());</span>
<span class="fc" id="L521">                }</span>
<span class="fc" id="L522">            }</span>
        }
        // makes setB inclusion reduction
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (setB) {</span>
            // computation of a topological sort
<span class="fc" id="L527">            List&lt;Node&gt; sort = this.topologicalSort();</span>
            // reduction of set B
<span class="fc bfc" id="L529" title="All 2 branches covered.">            for (Node to : sort) {</span>
<span class="fc" id="L530">                Concept cto = (Concept) to;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                for (Object source : this.getSuccessorNodes(to)) {</span>
<span class="fc" id="L532">                    Concept csource = (Concept) source;</span>
<span class="fc" id="L533">                    cto.getSetB().removeAll(csource.getSetB());</span>
<span class="fc" id="L534">                }</span>
<span class="fc" id="L535">            }</span>
        }
<span class="fc" id="L537">        return true;</span>
    }

    /**
     * Replaces set A of each join irreducible node by the difference between
     * itself and set A of the unique predecessor.
     *
     * Others closed sets are replaced by an emptyset.
     *
     * @return a boolean
     *
     * @todo Comment the return
     */
    public boolean makeIrreduciblesReduction() {
        // make inclusion reduction
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (this.makeInclusionReduction()) {</span>
            // check if not set A reduced concepts are join irreducibles
            // and if not set B reduced concepts are meet irreducibles
<span class="fc" id="L555">            TreeSet&lt;Node&gt; joinIrr = this.joinIrreducibles();</span>
<span class="fc" id="L556">            TreeSet&lt;Node&gt; meetIrr = this.meetIrreducibles();</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            for (Object node : this.getNodes()) {</span>
<span class="fc" id="L558">                Concept c = (Concept) node;</span>
<span class="pc bpc" id="L559" title="1 of 6 branches missed.">                if (c.hasSetA() &amp;&amp; !c.getSetA().isEmpty() &amp;&amp; !joinIrr.contains(c)) {</span>
<span class="fc" id="L560">                    c.putSetA(new ComparableSet());</span>
                }
<span class="fc bfc" id="L562" title="All 6 branches covered.">                if (c.hasSetB() &amp;&amp; !c.getSetB().isEmpty() &amp;&amp; !meetIrr.contains(c)) {</span>
<span class="fc" id="L563">                    c.putSetB(new ComparableSet());</span>
                }
<span class="fc" id="L565">            }</span>
        }
<span class="fc" id="L567">        return true;</span>
    }

    /**
     * Returns a lattice where edges are valuated by the difference between set
     * A of two adjacent concepts.
     *
     * @return a boolean
     *
     * @todo Change comment
     */
    public boolean makeEdgeValuation() {
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L580">            return false;</span>
        }
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">        for (Object n1 : this.getNodes()) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            for (Object ed : this.getSuccessorEdges((Node) n1)) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (!((Edge) ed).hasContent()) {</span>
<span class="nc" id="L585">                    Node n2 = ((Edge) ed).getTarget();</span>
<span class="nc" id="L586">                    TreeSet diff = new TreeSet();</span>
<span class="nc" id="L587">                    diff.addAll(((Concept) n2).getSetA());</span>
<span class="nc" id="L588">                    diff.removeAll(((Concept) n1).getSetA());</span>
<span class="nc" id="L589">                    ((Edge) ed).setContent(diff);</span>
                }
<span class="nc" id="L591">            }</span>
<span class="nc" id="L592">        }</span>
<span class="fc" id="L593">        return true;</span>
    }

    /*
     * --------------- LATTICE GENERATION METHODS ------------
     */
    /**
     * Returns a lattice where join irreducibles node's content is replaced by
     * the first element of set A.
     *
     * Other nodes are replaced by a new comparable.
     *
     * @return a lattice
     */
    public Lattice getJoinReduction() {
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L609">            return null;</span>
        }
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if (!this.containsAllSetA()) {</span>
<span class="nc" id="L612">            return null;</span>
        }
<span class="fc" id="L614">        Lattice lattice = new Lattice();</span>
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L616">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L617">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L618">        TreeSet&lt;Node&gt; joinIrr = csl.joinIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L620">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L622">            Concept c = (Concept) node;</span>
            Node nred;
<span class="pc bpc" id="L624" title="1 of 4 branches missed.">            if (c.hasSetA() &amp;&amp; joinIrr.contains(node)) {</span>
<span class="fc" id="L625">                nred = new Node(c.getSetA().first());</span>
            } else {
<span class="fc" id="L627">                nred = new Node();</span>
            }
<span class="fc" id="L629">            reduced.put((Node) node, nred);</span>
<span class="fc" id="L630">        }</span>
        // addtion of nodes to lattice
<span class="fc bfc" id="L632" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L633">            lattice.addNode(reduced.get(node));</span>
<span class="fc" id="L634">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (Object source : csl.getNodes()) {</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            for (Object target : csl.getSuccessorNodes((Node) source)) {</span>
<span class="fc" id="L638">                lattice.addEdge(reduced.get(source), reduced.get(target));</span>
<span class="fc" id="L639">            }</span>
<span class="fc" id="L640">        }</span>
<span class="fc" id="L641">        return lattice;</span>
    }

    /**
     * Returns a lattice where meet irreducibles node's content is replaced by
     * the first element of set B.
     *
     * Other nodes are replaced by a new comparable.
     *
     * @return a lattice
     */
    public Lattice getMeetReduction() {
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L654">            return null;</span>
        }
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (!this.containsAllSetB()) {</span>
<span class="nc" id="L657">            return null;</span>
        }
<span class="fc" id="L659">        Lattice lattice = new Lattice();</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L661">            return lattice;</span>
        }
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L664">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L665">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L666">        TreeSet&lt;Node&gt; meetIrr = csl.meetIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L668">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L670">            Concept c = (Concept) node;</span>
            Node nred;
<span class="pc bpc" id="L672" title="1 of 4 branches missed.">            if (c.hasSetB() &amp;&amp; meetIrr.contains(node)) {</span>
<span class="fc" id="L673">                nred = new Node(c.getSetB().first());</span>
            } else {
<span class="fc" id="L675">                nred = new Node();</span>
            }
<span class="fc" id="L677">            reduced.put((Node) node, nred);</span>
<span class="fc" id="L678">        }</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L680">            lattice.addNode(reduced.get(node));</span>
<span class="fc" id="L681">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L683" title="All 2 branches covered.">        for (Object source : csl.getNodes()) {</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            for (Object target : csl.getSuccessorNodes((Node) source)) {</span>
<span class="fc" id="L685">                lattice.addEdge(reduced.get(source), reduced.get(target));</span>
<span class="fc" id="L686">            }</span>
<span class="fc" id="L687">        }</span>
<span class="fc" id="L688">        return lattice;</span>
    }

    /**
     * Returns a lattice where each join irreducible concept is replaced by a
     * node containing the first element of set A, and each meet irreducible
     * concept is replaced by a node contining the first element of set B.
     *
     * A concept that is at once join and meet irreducible is replaced by a node
     * containing the first element of set A and the first element of set B in a
     * set. Other nodes are replaced by an empty node.
     *
     * @return a lattice
     */
    public Lattice getIrreduciblesReduction() {
<span class="fc" id="L703">        Lattice lattice = new Lattice();</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (!this.containsConcepts()) {</span>
<span class="nc" id="L705">            return lattice;</span>
        }
        //ConceptLattice csl = new ConceptLattice (this);
<span class="fc" id="L708">        ConceptLattice csl = this.clone();</span>
<span class="fc" id="L709">        csl.makeIrreduciblesReduction();</span>
<span class="fc" id="L710">        TreeSet&lt;Node&gt; joinIrr = csl.joinIrreducibles();</span>
<span class="fc" id="L711">        TreeSet&lt;Node&gt; meetIrr = csl.meetIrreducibles();</span>
        // addition to lattice of a comparable issued from each reduced closed set
<span class="fc" id="L713">        TreeMap&lt;Node, Node&gt; reduced = new TreeMap&lt;Node, Node&gt;();</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L715">            Concept c = (Concept) node;</span>
            // create a new Node with two indexed elements: the first of set A and the first of set B
<span class="pc bpc" id="L717" title="2 of 8 branches missed.">            if (c.hasSetA() &amp;&amp; c.hasSetB() &amp;&amp; meetIrr.contains(c) &amp;&amp; joinIrr.contains(c)) {</span>
<span class="nc" id="L718">                TreeSet&lt;Comparable&gt; content = new TreeSet&lt;Comparable&gt;();</span>
<span class="nc" id="L719">                content.add(c.getSetA().first());</span>
<span class="nc" id="L720">                content.add(c.getSetB().first());</span>
<span class="nc" id="L721">                Node nred = new Node(content);</span>
<span class="nc" id="L722">                reduced.put((Node) node, nred);</span>
<span class="pc bpc" id="L723" title="1 of 4 branches missed.">            } else if (c.hasSetA() &amp;&amp; joinIrr.contains(node)) {</span>
                // create a new Node with the first element of set A
<span class="fc" id="L725">                Node nred = new Node(((Concept) node).getSetA().first());</span>
<span class="fc" id="L726">                reduced.put((Node) node, nred);</span>
<span class="fc bfc" id="L727" title="All 4 branches covered.">            } else if (c.hasSetB() &amp;&amp; meetIrr.contains(node)) {</span>
                // create a new Node with the first element of set A
<span class="fc" id="L729">                Node nred = new Node(((Concept) node).getSetB().first());</span>
<span class="fc" id="L730">                reduced.put((Node) node, nred);</span>
<span class="fc" id="L731">            } else {</span>
<span class="fc" id="L732">                reduced.put((Node) node, new Node());</span>
            }
<span class="fc" id="L734">        }</span>
        // addtion of nodes to lattice
<span class="fc bfc" id="L736" title="All 2 branches covered.">        for (Object node : csl.getNodes()) {</span>
<span class="fc" id="L737">            lattice.addNode(reduced.get(node));</span>
<span class="fc" id="L738">        }</span>
        // addtion of edges to lattice
<span class="fc bfc" id="L740" title="All 2 branches covered.">        for (Object source : csl.getNodes()) {</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">            for (Object target : csl.getSuccessorNodes((Node) source)) {</span>
<span class="fc" id="L742">                lattice.addEdge(reduced.get(source), reduced.get(target));</span>
<span class="fc" id="L743">            }</span>
<span class="fc" id="L744">        }</span>
<span class="fc" id="L745">        return lattice;</span>
    }

    /**
     * Returns iceberg lattice whose concept contains enough observations.
     *
     * @deprecated use getConceptIceberg method from ClosureSystem class
     * instead. Are kept only concept whose number of observation is over
     * threshold. A top node is added to keep the lattice structure.
     *
     * @param threshold used to determine nodes to be kept.
     *
     * @return iceberg lattice whose concept contains enough observations.
     */
    @Deprecated
    public ConceptLattice iceberg(float threshold) {
<span class="fc" id="L761">        ConceptLattice l = new ConceptLattice();</span>
<span class="fc" id="L762">        Concept b = (Concept) this.bottom();</span>
<span class="fc" id="L763">        int card = b.getSetB().size();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        for (Object node : this.getNodes()) {</span>
<span class="fc" id="L765">            Concept cpt = (Concept) node;</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">            if ((float) cpt.getSetB().size() / (float) card &gt;= threshold) {</span>
<span class="fc" id="L767">                l.addNode((Node) node);</span>
            }
<span class="fc" id="L769">        }</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">        for (Object f : l.getNodes()) {</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">            for (Object t : l.getNodes()) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                if (this.containsEdge((Node) f, (Node) t)) {</span>
<span class="fc" id="L773">                    l.addEdge((Node) f, (Node) t);</span>
                }
<span class="fc" id="L775">            }</span>
<span class="fc" id="L776">        }</span>
<span class="fc" id="L777">        Node t = this.top();</span>
<span class="fc" id="L778">        l.addNode(t);</span>
        // TODO use Node&lt;Concept&gt;
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (Object node : l.getWells()) {</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">            if (!node.equals(t)) {</span>
<span class="nc" id="L782">                l.addEdge((Node) node, t);</span>
            }
<span class="fc" id="L784">        }</span>
<span class="fc" id="L785">        return l;</span>
    }

    /**
     * Returns the Hasse diagramme of the closed set lattice of the specified
     * closure system issued from the specified concept.
     *
     * Immediate successors generation is an adaptation of Bordat's theorem
     * stating that there is a bijection between minimal strongly connected
     * component of the precedence subgraph issued from the specified node, and
     * its immediate successors.
     *
     * This treatment is performed in O(cCl|S|^3log g) where S is the initial
     * set of elements, c is the number of closed sets that could be exponential
     * in the worst case, Cl is the closure computation complexity and g is the
     * number of minimal generators of the lattice.
     *
     * @param n    a concept
     * @param init a closure system
     */
    public void recursiveDiagramLattice(Concept n, ClosureSystem init) {
<span class="fc" id="L806">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = this.immediateSuccessors(n, init);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (TreeSet&lt;Comparable&gt; setX : immSucc) {</span>
<span class="fc" id="L808">            Concept c = new Concept(new TreeSet(setX), false);</span>
<span class="fc" id="L809">            Concept ns = (Concept) this.getNode(c);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">            if (ns != null) {</span>
                // when ns already exists, addition of a new edge
<span class="fc" id="L812">                this.addEdge(n, ns);</span>
            } else { // when ns don't already exists, addition of a new node and recursive treatment
<span class="fc" id="L814">                this.addNode(c);</span>
<span class="fc" id="L815">                this.addEdge(n, c);</span>
<span class="fc" id="L816">                this.recursiveDiagramLattice(c, init);</span>
            }
<span class="fc" id="L818">        }</span>
<span class="fc" id="L819">    }</span>

    /**
     * Returns the Hasse diagramme of the closed set iceberg of the specified
     * closure system issued from the specified concept.
     *
     * Immediate successors generation is an adaptation of Bordat's theorem
     * stating that there is a bijection between minimal strongly connected
     * component of the precedence subgraph issued from the specified node, and
     * its immediate successors.
     *
     * This treatment is performed in O(cCl|S|^3log g) where S is the initial
     * set of elements, c is the number of closed sets that could be exponential
     * in the worst case, Cl is the closure computation complexity and g is the
     * number of minimal generators of the lattice.
     *
     * @param n         a concept
     * @param init      a closure system
     * @param threshold a support threshold, as a number of observations
     */
    private void recursiveDiagramIceberg(Concept n, ClosureSystem init, int threshold) {
<span class="nc" id="L840">        Context context = (Context) init;</span>
<span class="nc" id="L841">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = this.immediateSuccessors(n, init);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">        for (TreeSet&lt;Comparable&gt; setX : immSucc) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (context.getExtentNb(setX) &gt;= threshold) {</span>
<span class="nc" id="L844">                Concept c = new Concept(new TreeSet(setX), false);</span>
<span class="nc" id="L845">                Concept ns = (Concept) this.getNode(c);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                if (ns != null) {</span>
<span class="nc" id="L847">                    this.addEdge(n, ns);</span>
                } else {
<span class="nc" id="L849">                    this.addNode(c);</span>
<span class="nc" id="L850">                    this.addEdge(n, c);</span>
<span class="nc" id="L851">                    this.recursiveDiagramIceberg(c, init, threshold);</span>
                }
            }
<span class="nc" id="L854">        }</span>
<span class="nc" id="L855">    }</span>

    /**
     * Returns the list of immediate successors of a given node of the lattice.
     *
     * This treatment is an adaptation of Bordat's theorem stating that there is
     * a bijection between minimal strongly connected component of the
     * precedence subgraph issued from the specified node, and its immediate
     * successors.
     *
     * This treatment is performed in O(Cl|S|^3log g) where S is the initial set
     * of elements, Cl is the closure computation complexity and g is the number
     * of minimal generators of the lattice.
     *
     * This treatment is recursively invoked by method recursiveDiagramlattice.
     * In this case, the dependance graph is initialised by method
     * recursiveDiagramMethod, and updated by this method, with addition some
     * news edges and/or new valuations on existing edges. When this treatment
     * is not invoked by method recursiveDiagramLattice, then the dependance
     * graph is initialised, but it may be not complete. It is the case for
     * example for on-line generation of the concept lattice.
     *
     * @param n    a node
     * @param init a closure system
     *
     * @return a set of immediate successors
     */
    public Vector&lt;TreeSet&lt;Comparable&gt;&gt; immediateSuccessors(Node n, ClosureSystem init) {
        // Initialisation of the dependance graph when not initialised by method recursiveDiagramLattice
<span class="fc bfc" id="L884" title="All 2 branches covered.">        if (!this.hasDependencyGraph()) {</span>
<span class="fc" id="L885">            ConcreteDGraph graph = new ConcreteDGraph();</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">            for (Comparable c : init.getSet()) {</span>
<span class="fc" id="L887">                graph.addNode(new Node(c));</span>
<span class="fc" id="L888">            }</span>
<span class="fc" id="L889">            this.setDependencyGraph(graph);</span>
        }
        // computes newVal, the subset to be used to valuate every new dependance relation
        // newVal = F\predecessors of F in the precedence graph of the closure system
        // For a non reduced closure system, the precedence graph is not acyclic,
        // and therefore strongly connected components have to be used.
<span class="fc" id="L895">        ComparableSet setF = new ComparableSet(((Concept) n).getSetA());</span>
<span class="fc" id="L896">        ConcreteDGraph prec = init.precedenceGraph();</span>
<span class="fc" id="L897">        DAGraph acyclPrec = prec.getStronglyConnectedComponent();</span>
<span class="fc" id="L898">        ComparableSet newVal = new ComparableSet();</span>
<span class="fc" id="L899">        newVal.addAll(setF);</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">        for (Object x : setF) {</span>
            // computes nx, the strongly connected component containing x
<span class="fc" id="L902">            Node nx = null;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">            for (Object cc : acyclPrec.getNodes()) {</span>
<span class="fc" id="L904">                TreeSet&lt;Node&gt; setCC = (TreeSet&lt;Node&gt;) ((Node) cc).getContent();</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">                for (Node y : setCC) {</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">                    if (x.equals(y.getContent())) {</span>
<span class="fc" id="L907">                        nx = (Node) cc;</span>
                    }
<span class="fc" id="L909">                }</span>
<span class="fc" id="L910">            }</span>
            // computes the minorants of nx in the acyclic graph
<span class="fc" id="L912">            SortedSet&lt;Node&gt; ccMinNx = acyclPrec.minorants(nx);</span>
            // removes from newVal every minorants of nx
<span class="fc bfc" id="L914" title="All 2 branches covered.">            for (Node cc : ccMinNx) {</span>
<span class="fc" id="L915">                TreeSet&lt;Node&gt; setCC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">                for (Node y : setCC) {</span>
<span class="fc" id="L917">                    newVal.remove(y.getContent());</span>
<span class="fc" id="L918">                }</span>
<span class="fc" id="L919">            }</span>
<span class="fc" id="L920">        }</span>
        // computes the node belonging in S\F
<span class="fc" id="L922">        TreeSet&lt;Node&gt; nodes = new TreeSet&lt;Node&gt;();</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">        for (Object in : this.getDependencyGraph().getNodes()) {</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">            if (!setF.contains(((Node) in).getContent())) {</span>
<span class="fc" id="L925">                nodes.add((Node) in);</span>
            }
<span class="fc" id="L927">        }</span>
        // computes the dependance relation between nodes in S\F
        // and valuated this relation by the subset of S\F
<span class="fc" id="L930">        TreeSet&lt;Edge&gt; edges = new TreeSet&lt;Edge&gt;();</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">        for (Node source : nodes) {</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">            for (Node target : nodes) {</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">                if (!source.equals(target)) {</span>
                    // check if source is in dependance relation with target
                    // i.e. &quot;source&quot; belongs to the closure of &quot;F+target&quot;
<span class="fc" id="L936">                    ComparableSet fPlusTo = new ComparableSet(setF);</span>
<span class="fc" id="L937">                    fPlusTo.add(target.getContent());</span>
<span class="fc" id="L938">                    fPlusTo = new ComparableSet(init.closure(fPlusTo));</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">                    if (fPlusTo.contains(source.getContent())) {</span>
                        // there is a dependance relation between source and target
                        // search for an existing edge between source and target
<span class="fc" id="L942">                        Edge ed = this.getDependencyGraph().getEdge(source, target);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">                        if (ed == null) {</span>
<span class="fc" id="L944">                            ed = new Edge(source, target, new TreeSet&lt;ComparableSet&gt;());</span>
<span class="fc" id="L945">                            this.getDependencyGraph().addEdge(ed);</span>
                        }
<span class="fc" id="L947">                        edges.add(ed);</span>
                        // check if F is a minimal set closed for dependance relation between source and target
<span class="fc" id="L949">                        ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).add(newVal);</span>
<span class="fc" id="L950">                        TreeSet&lt;ComparableSet&gt; valEd = new TreeSet&lt;ComparableSet&gt;((TreeSet&lt;ComparableSet&gt;) ed.getContent());</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">                        for (ComparableSet x1 : valEd) {</span>
<span class="fc bfc" id="L952" title="All 4 branches covered.">                            if (x1.containsAll(newVal) &amp;&amp; !newVal.containsAll(x1)) {</span>
<span class="fc" id="L953">                                ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(x1);</span>
                            }
<span class="fc bfc" id="L955" title="All 4 branches covered.">                            if (!x1.containsAll(newVal) &amp;&amp; newVal.containsAll(x1)) {</span>
<span class="fc" id="L956">                                ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(newVal);</span>
                            }
<span class="fc" id="L958">                        }</span>
                    }
                }
<span class="fc" id="L961">            }</span>
<span class="fc" id="L962">        }</span>
        // computes the dependance subgraph of the closed set F as the reduction
        // of the dependance graph composed of nodes in S\A and edges of the dependance relation
<span class="fc" id="L965">        ConcreteDGraph sub = this.getDependencyGraph().getSubgraphByNodes(nodes);</span>
<span class="fc" id="L966">        ConcreteDGraph delta = sub.getSubgraphByEdges(edges);</span>
        // computes the sources of the CFC of the dependance subgraph
        // that corresponds to successors of the closed set F
<span class="fc" id="L969">        DAGraph cfc = delta.getStronglyConnectedComponent();</span>
<span class="fc" id="L970">        SortedSet&lt;Node&gt; sccMin = cfc.getSinks();</span>
<span class="fc" id="L971">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = new Vector&lt;TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">        for (Node n1 : sccMin) {</span>
<span class="fc" id="L973">            TreeSet s = new TreeSet(setF);</span>
<span class="fc" id="L974">            TreeSet&lt;Node&gt; toadd = (TreeSet&lt;Node&gt;) n1.getContent();</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">            for (Node n2 : toadd) {</span>
<span class="fc" id="L976">                s.add(n2.getContent());</span>
<span class="fc" id="L977">            }</span>
<span class="fc" id="L978">            immSucc.add(s);</span>
<span class="fc" id="L979">        }</span>
<span class="fc" id="L980">        return immSucc;</span>
    }

    /**
     * Save the description of this component in a file whose name is specified.
     *
     * @param filename the name of the file
     *
     * @throws IOException When an IOException occurs
     */
    @Override
    public void save(final String filename) throws IOException {
<span class="fc" id="L992">        Filer.getInstance().save(this, ConceptLatticeIOFactory.getInstance(), filename);</span>
<span class="fc" id="L993">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>