<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClosureSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">org.thegalactic.lattice</a> &gt; <span class="el_source">ClosureSystem.java</span></div><h1>ClosureSystem.java</h1><pre class="source lang-java linenums">package org.thegalactic.lattice;

/*
 * ClosureSystem.java
 *
 * Copyright: 2010-2015 Karell Bertet, France
 * Copyright: 2015-2016 The Galactic Organization, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices.
 * You can redistribute it and/or modify it under the terms of the CeCILL-B license.
 */
import java.io.IOException;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;

import org.thegalactic.dgraph.DAGraph;
import org.thegalactic.dgraph.ConcreteDGraph;
import org.thegalactic.dgraph.Node;
import org.thegalactic.util.ComparableSet;

/**
 * This class is an abstract class defining the common behavior of closure
 * systems, and specialy its closed set lattice generation.
 *
 * Both a context and an implicational system have properties of a closure
 * system, and therefore extend this class.
 *
 * A closure system is formaly defined by a set of indexed elements and a
 * closure operator (abstract methods {@link #getSet} and {@link #closure}).
 *
 * Abstract method {@link #save} also describe the common behavior of a closure
 * system.
 *
 * However, this abstract class provides both abstract and non abstract methods.
 *
 * Although abstract methods depends on data, and so have to be implemented by
 * each extended class, non abstract methods only used property of a closure
 * system. It is the case for methods {@link #nextClosure} (that computes the
 * next closure of the specified one according to the lectic order implemented
 * the well-known Wille algorithm) invoked by method {@link #allClosures} and
 * the main method {@link #closedSetLattice} (where lattice can be transitively
 * closed or reduced).
 *
 *
 * ![ClosureSystem](ClosureSystem.png)
 *
 * @uml ClosureSystem.png
 * !include resources/org/thegalactic/lattice/ClosureSystem.iuml
 *
 * hide members
 * show ClosureSystem members
 * class ClosureSystem #LightCyan
 * title ClosureSystem UML graph
 */
<span class="fc" id="L59">public abstract class ClosureSystem {</span>

    /*
     * ------------- ABSTRACT METHODS ------------------
     */
    /**
     * Returns the set of elements of the closure system.
     *
     * @return the set of elements of the closure system
     */
    public abstract SortedSet&lt;Comparable&gt; getSet();

    /**
     * Returns the closure of the specified set.
     *
     * @param set The specified set
     *
     * @return The closure
     */
    public abstract TreeSet&lt;Comparable&gt; closure(TreeSet&lt;Comparable&gt; set);

    /**
     * Saves this component in a file which name is specified.
     *
     * @param file name of file
     *
     * @throws IOException When an IOException occurs
     */
    public abstract void save(String file) throws IOException;

    /*
     * ------------- IMPLEMENTED METHODS ------------------
     */
    /**
     * Returns the closed set lattice of this component.
     *
     * A true value of the boolean `diagram` indicates that the Hasse diagramm
     * of the lattice is computed (i.e. it is transitively reduced), whereas a
     * false value indicates that the lattice is transitively closed
     *
     * A transitively reduced lattice is generated by the static method
     * `ConceptLattice diagramLattice (ClosureSystem init)` that implements an
     * adaptation of Bordat's algorithm. This adaptation computes the dependance
     * graph while the lattice is generated, with the same complexity.
     *
     * A transitively closed lattice is generated bye well-known Next Closure
     * algorithm. In this case, the dependance graph of the lattice isn't
     * computed.
     *
     * @param diagram a boolean indicating if the Hasse diagramm of the lattice
     *                is computed or not.
     *
     * @return The concept lattice
     */
    public ConceptLattice closedSetLattice(boolean diagram) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (diagram) {</span>
<span class="fc" id="L115">            return ConceptLattice.diagramLattice(this);</span>
        } else {
<span class="fc" id="L117">            return ConceptLattice.completeLattice(this);</span>
        }
    }

    /**
     * Returns the lattice of this component.
     *
     * @return The concept lattice
     */
    public ConceptLattice lattice() {
<span class="fc" id="L127">        return this.closedSetLattice(true);</span>
    }

    /**
     * Returns all the closed sets of the specified closure system (that can be
     * an IS or a context).
     *
     * Closed sets are generated in lecticaly order, with the emptyset's closure
     * as first closed set, using the Ganter's Next Closure algorithm.
     *
     * Therefore, closed sets have to be comparable using `ComparableSet` class.
     * This treatment is performed in O(cCl|S|^3) where S is the initial set of
     * elements, c is the number of closed sets that could be exponential in the
     * worst case, and Cl is the closure computation complexity.
     *
     * @return all the closeds set in the lectically order.
     */
    public Vector&lt;Concept&gt; allClosures() {
<span class="fc" id="L145">        Vector&lt;Concept&gt; allclosure = new Vector&lt;Concept&gt;();</span>
        // first closure: closure of the empty set
<span class="fc" id="L147">        allclosure.add(new Concept(this.closure(new ComparableSet()), false));</span>
<span class="fc" id="L148">        Concept cl = allclosure.firstElement();</span>
        // next closures in lectically order
<span class="fc" id="L150">        boolean continu = true;</span>
        do {
<span class="fc" id="L152">            cl = this.nextClosure(cl);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (allclosure.contains(cl)) {</span>
<span class="fc" id="L154">                continu = false;</span>
            } else {
<span class="fc" id="L156">                allclosure.add(cl);</span>
            }
<span class="fc bfc" id="L158" title="All 2 branches covered.">        } while (continu);</span>

<span class="fc" id="L160">        return allclosure;</span>
    }

    /**
     * Returns the lecticaly next closed set of the specified one.
     *
     * This treatment is an implementation of the best knowm algorithm of Wille
     * whose complexity is in O(Cl|S|^2), where S is the initial set of
     * elements, and Cl is the closure computation complexity.
     *
     * @param cl a concept
     *
     * @return the lecticaly next closed set
     */
    public Concept nextClosure(Concept cl) {
<span class="fc" id="L175">        TreeSet&lt;Comparable&gt; set = new TreeSet(this.getSet());</span>
<span class="fc" id="L176">        boolean success = false;</span>
<span class="fc" id="L177">        TreeSet setA = new TreeSet(cl.getSetA());</span>
<span class="fc" id="L178">        Comparable ni = set.last();</span>
        do {
<span class="fc" id="L180">            ni = (Comparable) set.last();</span>
<span class="fc" id="L181">            set.remove(ni);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (!setA.contains(ni)) {</span>
<span class="fc" id="L183">                setA.add(ni);</span>
<span class="fc" id="L184">                TreeSet setB = this.closure(setA);</span>
<span class="fc" id="L185">                setB.removeAll(setA);</span>
<span class="fc bfc" id="L186" title="All 4 branches covered.">                if (setB.isEmpty() || ((Comparable) setB.first()).compareTo(ni) &gt;= 1) {</span>
<span class="fc" id="L187">                    setA = this.closure(setA);</span>
<span class="fc" id="L188">                    success = true;</span>
                } else {
<span class="fc" id="L190">                    setA.remove(ni);</span>
                }
<span class="fc" id="L192">            } else {</span>
<span class="fc" id="L193">                setA.remove(ni);</span>
            }
<span class="fc bfc" id="L195" title="All 4 branches covered.">        } while (!success &amp;&amp; ni.compareTo(this.getSet().first()) &gt;= 1);</span>
<span class="fc" id="L196">        return new Concept(setA, false);</span>
    }

    /**
     * Returns the precedence graph of this component.
     *
     * Nodes of the graph are elements of this component. There is an edge from
     * element a to element b when a belongs to the closure of b.
     *
     * The rule a -&gt; a isn't added to the precedence graph
     *
     * When precedence graph is acyclic, then this component is a reduced one.
     *
     * @return the precedence graph
     */
    public ConcreteDGraph&lt;Comparable, ?&gt; precedenceGraph() {
        // compute a TreeMap of closures for each element of the component
<span class="fc" id="L213">        TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; closures = new TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (Comparable x : this.getSet()) {</span>
<span class="fc" id="L215">            ComparableSet setX = new ComparableSet();</span>
<span class="fc" id="L216">            setX.add(x);</span>
<span class="fc" id="L217">            closures.put(x, this.closure(setX));</span>
<span class="fc" id="L218">        }</span>
        // nodes of the graph are elements
<span class="fc" id="L220">        ConcreteDGraph&lt;Comparable, ?&gt; prec = new ConcreteDGraph&lt;Comparable, Object&gt;();</span>
<span class="fc" id="L221">        TreeMap&lt;Comparable, Node&gt; nodeCreated = new TreeMap&lt;Comparable, Node&gt;();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (Comparable x : this.getSet()) {</span>
<span class="fc" id="L223">            Node node = new Node(x);</span>
<span class="fc" id="L224">            prec.addNode(node);</span>
<span class="fc" id="L225">            nodeCreated.put(x, node);</span>
<span class="fc" id="L226">        }</span>
        // edges of the graph are closures containments
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for (Comparable source : this.getSet()) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            for (Comparable target : this.getSet()) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (!source.equals(target)) {</span>
                    // check if source belongs to the closure of target
<span class="fc bfc" id="L232" title="All 2 branches covered.">                    if (closures.get(target).contains(source)) {</span>
<span class="fc" id="L233">                        prec.addEdge(nodeCreated.get(source), nodeCreated.get(target));</span>
                    }
                }
<span class="fc" id="L236">            }</span>
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">        return prec;</span>
    }

    /**
     * This function returns all reducible elements.
     *
     * A reducible elements is equivalent by closure to one or more other
     * attributes. Reducible elements are computed using the precedence graph of
     * the closure system. Complexity is in O()
     *
     * @return The map of reductible attributes with their equivalent attributes
     */
    public TreeMap&lt;Object, TreeSet&gt; getReducibleElements() {
        // If you can't remove nodes, put them in the rubbish bin ...
<span class="fc" id="L252">        TreeSet&lt;Node&gt; rubbishBin = new TreeSet&lt;Node&gt;();</span>
        // Initialise a map Red of reducible attributes
<span class="fc" id="L254">        TreeMap&lt;Object, TreeSet&gt; red = new TreeMap();</span>
        // Initialise the precedence graph G of the closure system
<span class="fc" id="L256">        ConcreteDGraph&lt;Comparable, ?&gt; graph = this.precedenceGraph();</span>
        // First, compute each group of equivalent attributes
        // This group will be a strongly connected component on the graph.
        // Then, only one element of each group is skipped, others will be deleted.
<span class="fc" id="L260">        DAGraph&lt;SortedSet&lt;Node&lt;Comparable&gt;&gt;, ?&gt; cfc = graph.getStronglyConnectedComponent();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        for (Node&lt;SortedSet&lt;Node&lt;Comparable&gt;&gt;&gt; node : cfc.getNodes()) {</span>
            // Get list of node of this component
<span class="fc" id="L263">            SortedSet&lt;Node&lt;Comparable&gt;&gt; sCC = node.getContent();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (sCC.size() &gt; 1) {</span>
<span class="fc" id="L265">                Node&lt;?&gt; y = sCC.first();</span>
<span class="fc" id="L266">                TreeSet yClass = new TreeSet();</span>
<span class="fc" id="L267">                yClass.add(y.getContent());</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                for (Node x : sCC) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                    if (!x.getContent().equals(y.getContent())) {</span>
<span class="fc" id="L270">                        rubbishBin.add(x); // instead of : graph.removeNode(x);</span>
<span class="fc" id="L271">                        red.put(x.getContent(), yClass);</span>
                    }
<span class="fc" id="L273">                }</span>
            }
<span class="fc" id="L275">        }</span>
        // Next, check if an attribute is equivalent to emptyset
        // i.e. its closure is equal to emptyset closure
<span class="fc" id="L278">        TreeSet&lt;Node&gt; sinks = new TreeSet&lt;Node&gt;(graph.getSinks());</span>
<span class="fc" id="L279">        sinks.removeAll(rubbishBin);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (sinks.size() == 1) {</span>
<span class="fc" id="L281">            Node s = sinks.first();</span>
<span class="fc" id="L282">            red.put(s.getContent(), new TreeSet());</span>
<span class="fc" id="L283">            rubbishBin.add(s); // instead of : graph.removeNode(s);</span>
        }
        // Finaly, checking a remaining attribute equivalent to its predecessors or not may reduce more attributes.
        // Check all remaining nodes of graph G
<span class="fc" id="L287">        TreeSet&lt;Node&gt; remainingNodes = new TreeSet&lt;Node&gt;();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (Node node : graph.getNodes()) {</span>
<span class="fc" id="L289">            remainingNodes.add(node);</span>
<span class="fc" id="L290">        }</span>
<span class="fc" id="L291">        remainingNodes.removeAll(rubbishBin);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (Node x : remainingNodes) {</span>
            // TODO getPredecessorNodes must return an iterator
<span class="fc" id="L294">            SortedSet&lt;Node&gt; predecessors = new TreeSet&lt;Node&gt;(graph.getPredecessorNodes(x));</span>
<span class="fc" id="L295">            predecessors.removeAll(rubbishBin);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (predecessors.size() &gt; 1) {</span>
                // Create the closure of x
<span class="fc" id="L298">                TreeSet set = new TreeSet();</span>
<span class="fc" id="L299">                set.add(x.getContent());</span>
<span class="fc" id="L300">                TreeSet closureSet = this.closure(set);</span>
                // Create the closure of predecessors
<span class="fc" id="L302">                TreeSet&lt;Comparable&gt; pred = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                for (Node node : predecessors) {</span>
<span class="fc" id="L304">                    pred.add((Comparable) node.getContent());</span>
<span class="fc" id="L305">                }</span>
<span class="fc" id="L306">                TreeSet&lt;Comparable&gt; closureP = this.closure(pred);</span>
                // Check the equality of two closures
<span class="pc bpc" id="L308" title="2 of 4 branches missed.">                if (closureSet.containsAll(closureP) &amp;&amp; closureP.containsAll(closureSet)) {</span>
<span class="nc" id="L309">                    red.put(x.getContent(), pred);</span>
                }
            }
<span class="fc" id="L312">        }</span>
        // Finally, return the list of reducible elements with their equivalent attributes.
<span class="fc" id="L314">        return red;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>