<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContextSerializerSLF.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lattices</a> &gt; <a href="index.source.html" class="el_package">org.thegalactic.context.io</a> &gt; <span class="el_source">ContextSerializerSLF.java</span></div><h1>ContextSerializerSLF.java</h1><pre class="source lang-java linenums">package org.thegalactic.context.io;

/*
 * ContextSerializerSLF.java
 *
 * Copyright: 2010-2015 Karell Bertet, France
 * Copyright: 2015-2016 The Galactic Organization, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of java-lattices.
 * You can redistribute it and/or modify it under the terms of CeCILL-B license.
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

import org.thegalactic.context.Context;
import org.thegalactic.io.Reader;
import org.thegalactic.io.Writer;

/**
 * This class defines the way for reading a context from a slf file.
 *
 */
public final class ContextSerializerSLF implements Reader&lt;Context&gt;, Writer&lt;Context&gt; {

    /**
     * String extension.
     */
    private static final String EXTENSION = &quot;slf&quot;;

    /**
     * Header.
     */
    private static final String HEADER = &quot;[Lattice]&quot;;

    /**
     * Objects.
     */
    private static final String OBJECTS = &quot;[Objects]&quot;;

    /**
     * Attributes.
     */
    private static final String ATTRIBUTES = &quot;[Attributes]&quot;;

    /**
     * relation.
     */
    private static final String RELATION = &quot;[relation]&quot;;

    /**
     * Misformed exception.
     */
    private static final String MISFORMED = &quot;Misformated SLF file.&quot;;

    /**
     * The singleton INSTANCE.
     */
<span class="fc" id="L67">    private static final ContextSerializerSLF INSTANCE = new ContextSerializerSLF();</span>

    /**
     * Return the singleton INSTANCE of this class.
     *
     * @return the singleton INSTANCE
     */
    public static ContextSerializerSLF getINSTANCE() {
<span class="fc" id="L75">        return INSTANCE;</span>
    }

    /**
     * Register this class for reading and writing .slf files.
     */
    public static void register() {
<span class="fc" id="L82">        ContextIOFactory.getInstance().registerReader(ContextSerializerSLF.getINSTANCE(), EXTENSION);</span>
<span class="fc" id="L83">        ContextIOFactory.getInstance().registerWriter(ContextSerializerSLF.getINSTANCE(), EXTENSION);</span>
<span class="fc" id="L84">    }</span>

    /**
     * This class is not designed to be publicly instantiated.
     */
<span class="fc" id="L89">    private ContextSerializerSLF() {</span>
<span class="fc" id="L90">    }</span>

    /**
     * Read a context from a file.
     *
     * The following format is respected:
     *
     * The number of objects and observation on two separated lines The list of
     * objects on seprated lines The list of attributes on separated lines
     *
     * then, for each observations, the list of its intent on a line, written
     * like 0 1 0
     *
     * ~~~
     * [Lattice]
     * 2
     * 3
     * [Objects]
     * 1 2
     * [Attributes]
     * a b c
     * [relation]
     * 0 1 0
     * 1 1 0
     * ~~~
     *
     * @param context a context to read
     * @param file    a file
     *
     * @throws IOException When an IOException occurs
     *
     * @todo use StreamTokenizer
     */
    public void read(final Context context, final BufferedReader file) throws IOException {

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (!file.readLine().equals(HEADER)) {</span>
<span class="nc" id="L126">            throw new IOException(MISFORMED);</span>
        }

<span class="fc" id="L129">        final int countObservations = Integer.parseInt(file.readLine());</span>
<span class="fc" id="L130">        final int countAttributes = Integer.parseInt(file.readLine());</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (!file.readLine().equals(OBJECTS)) {</span>
<span class="nc" id="L133">            throw new IOException(MISFORMED);</span>
        }

<span class="fc" id="L136">        final List&lt;Comparable&gt; observations = new ArrayList(countObservations);</span>
<span class="fc" id="L137">        final List&lt;Comparable&gt; attributes = new ArrayList(countAttributes);</span>
<span class="fc" id="L138">        final TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; intent = new TreeMap();</span>
<span class="fc" id="L139">        final TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; extent = new TreeMap();</span>

<span class="fc" id="L141">        String line = file.readLine();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        while (!ATTRIBUTES.equals(line)) {</span>
<span class="fc" id="L143">            observations.add(line);</span>
<span class="fc" id="L144">            intent.put(line, new TreeSet());</span>
<span class="fc" id="L145">            line = file.readLine();</span>
        }
<span class="fc" id="L147">        line = file.readLine();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        while (!RELATION.equals(line)) {</span>
<span class="fc" id="L149">            attributes.add(line);</span>
<span class="fc" id="L150">            extent.put(line, new TreeSet());</span>
<span class="fc" id="L151">            line = file.readLine();</span>
        }

<span class="fc" id="L154">        context.addAllToAttributes(new TreeSet(attributes));</span>
<span class="fc" id="L155">        context.addAllToObservations(new TreeSet(observations));</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (int i = 0; i &lt; countObservations; i++) {</span>
<span class="fc" id="L158">            line = file.readLine();</span>
<span class="fc" id="L159">            final StringTokenizer tokenizer = new StringTokenizer(line);</span>
<span class="fc" id="L160">            int count = 0;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            while (tokenizer.hasMoreTokens()) {</span>
<span class="fc" id="L162">                final String next = tokenizer.nextToken();</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (&quot;1&quot;.equals(next)) {</span>
<span class="fc" id="L164">                    context.addExtentIntent(observations.get(i), attributes.get(count));</span>
                }
<span class="fc" id="L166">                count++;</span>
<span class="fc" id="L167">            }</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            if (count != countAttributes) {</span>
<span class="nc" id="L169">                throw new IOException(MISFORMED);</span>
            }
        }
<span class="fc" id="L172">        context.setBitSets();</span>
<span class="fc" id="L173">    }</span>

    /**
     * Write a context to a file.
     *
     * The Standard Lattice Format SLF format file is respected :
     *
     * The following format is respected:
     *
     * The number of objects and observation on two separated lines The list of
     * objects on seprated lines The list of attributes on separated lines
     *
     * then, for each observations, the list of its intent on a line, written
     * like 0 1 0
     *
     * ~~~
     * [Lattice]
     * 2
     * 3
     * [Objects]
     * 1
     * 2
     * [Attributes]
     * a
     * b
     * c
     * [relation]
     * 0 1 0
     * 1 1 0
     * ~~~
     *
     * @param context a context to write
     * @param file    a file
     *
     * @throws IOException When an IOException occurs
     */
    public void write(final Context context, final BufferedWriter file) throws IOException {
<span class="fc" id="L210">        file.write(HEADER);</span>
<span class="fc" id="L211">        file.newLine();</span>
<span class="fc" id="L212">        file.write(String.valueOf(context.getObservations().size()));</span>
<span class="fc" id="L213">        file.newLine();</span>
<span class="fc" id="L214">        file.write(String.valueOf(context.getAttributes().size()));</span>
<span class="fc" id="L215">        file.newLine();</span>
<span class="fc" id="L216">        file.write(OBJECTS);</span>
<span class="fc" id="L217">        file.newLine();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (final Comparable observation : context.getObservations()) {</span>
<span class="fc" id="L219">            file.write(observation.toString());</span>
<span class="fc" id="L220">            file.newLine();</span>
<span class="fc" id="L221">        }</span>
<span class="fc" id="L222">        file.write(ATTRIBUTES);</span>
<span class="fc" id="L223">        file.newLine();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (final Comparable attribute : context.getAttributes()) {</span>
<span class="fc" id="L225">            file.write(attribute.toString());</span>
<span class="fc" id="L226">            file.newLine();</span>
<span class="fc" id="L227">        }</span>
<span class="fc" id="L228">        file.write(RELATION);</span>
<span class="fc" id="L229">        file.newLine();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (final Comparable observation : context.getObservations()) {</span>
<span class="fc" id="L231">            final SortedSet&lt;Comparable&gt; intent = context.getIntent(observation);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            for (final Comparable attribute : context.getAttributes()) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (intent.contains(attribute)) {</span>
<span class="fc" id="L234">                    file.write(&quot;1 &quot;);</span>
                } else {
<span class="fc" id="L236">                    file.write(&quot;0 &quot;);</span>
                }
<span class="fc" id="L238">            }</span>
<span class="fc" id="L239">            file.newLine();</span>
<span class="fc" id="L240">        }</span>
<span class="fc" id="L241">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>